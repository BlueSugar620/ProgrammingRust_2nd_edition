# 基本的な型

- 明示的に書いた型を用いて、 Rust コンパイラの型推論機構が残りの型のほとんどを推論 (infer) してくれます。実際には、変数や式の型は一意に決まることが多いです。そのような場合にはコンパイラに任せることができます。

- 関数をジェネリック (generic) にすることができます。 1 つの定義でさまざまなユースケースに対応することができます。

| 型 | 説明 | 値の例 |
| ---- | ---- | ---- |
| `i8, i16, i32, i64, i128`<br>`u8, u16, u32, u64, u128` | 指定されたビット長の符号あり、符号なし整数 | `42, -5i8, 0x400u16, 0o100i16, 20_922_789_888_000u64, b'*'` |
| `isize, usize` | 計算機のアドレスと同じサイズの符号あり、符号なし整数 | `137, -0b0101_0010isize, 0xffff_fc00usize` |
| `f32, f64` | 単精度もしくは倍精度のIEEE浮動小数点数 | `1.61803, 3.14f32, 6.0221e23f64` |
| `bool` | 真偽値 | `true, false` |
| `char` | ユニコード文字、 32 ビット長 | `'*', '\n', '字', '\x7f', '\u{CA0}'` |
| `(char, u8, i32)` | タプル : 型が混ざってもよい | `('%', 0x7f, -1)` |
| `()` | 「ユニット」（空の）タプル | `()` |
| `struct S { x: f32, y: f32 }` | 名前付きフィールド型構造体 | `S { x: 120.0, y: 209.0 }` |
| `struct T(i32, char)` | タプル型構造体 | `T(120, 'X')` |
| `struct E` | ユニット型構造体、フィールドを持たない | `E` |
| `enum Attend { OnTime, Late(u32) }` | 列挙型、代数データ型 | `Attend::Late(5), Attend::OnTime` |
| `Box<Attend>` | ボックス、ヒープ上の値へのポインタを保持する | `Box::new(Late(15))` |
| `&i32, &mut i32` | 共有参照と可変参照 : 参照先を所有していないので参照先よりも長生きしてはならない | `&s.y, &mut v` |
| `String` | UTF-8 文字列。サイズは動的に変化する | `"ラーメン: ramen".to_string()` |
| `&str` | 文字列への参照。UTF-8 テキストへの、所有権のない参照 | `"そば: soba", &s[0..12]` |
| `[f64; 4], [u8; 256]` | 固定長配列。要素は全て同じ型 | `[1.0, 0.0, 0.0, 1.0], [b' '; 256]` |
| `Vec<f64>` | 可変長ベクタ。要素は全て同じ型 | `vec![0.367, 2.718, 7.389]` |
| `&[u8], &mut [u8]` | スライスへの参照。配列やベクタの一部への参照。ポインタと長さからなる。 | `&v[10..20], &mut a[..]` |
| `Option<&str>` | オプション型 : `None` (値がない) もしくは `Some(v)` (値が存在) | `Some("Dr."), None` |
| `Result<u64, Error>` | 失敗する可能性のある操作の結果。 `Ok(v)` (成功時)もしくは `Err(e)` (失敗時) | `Ok(4096), Err(Error::last_os_error())` |
| `&dyn Any, &mut dyn Read` | トレイトオブジェクト。指定されたメソッドの集合を実装した任意の値への参照 | `value as &dyn Any, &mut file as &mut dyn Read` |
| `fn(&str, usize) -> isize` | 関数へのポインタ | `i32::saturating_add` |
| (クロージャの型は記述する方法がない) | クロージャ | `|a, b| a * a + b * b` |

## 固定長数値

Rust の数値リテラルには型を後ろに付けます。
型を省略すると Rust コンパイラは、型が決定できるようになるまで問題を先送りにします。
最終的に複数の型が候補に残った場合、その候補の中に `i32` があれば、 `i32` をデフォルトとして用います。
`i32` が候補に残っていなければ、曖昧だということでエラーになります。

`0x, 0o, 0b` を冒頭につけると、 16 進数、 8 進数、 2 進数のリテラルになります。

長い数を読みやすくするために、数字の間にアンダースコアを入れてもよいです。
アンダースコアを入れる位置はどこでもよいです。

Rust では数値型と `char` 型は区別されていますが、 `u8` の値を表す文字のようなリテラル、バイトリテラル (byte literals) が用意されています。
`b'X'` は文字 `X` に対するASCIIコードの `u8` の値となります。
`A` の ASCII コードは `65` なので、 `b'A'` と `65u8` は全く同じものです。
バイトリテラルには、 ASCII 文字しか使用できません。

ある整数型から別の整数型への変換は `as` 演算子で行います。

### オーバーフローなど

デバッグビルドでは、整数演算中のオーバーフローは検知され、パニックを発生させます。
リリースビルドでは、ラップ (wrap) します。
つまり、数学的に正しい答えに対して、値の範囲で除算をした際の余りを返します。
いずれの場合も、未定義動作ではないです。

#### チェック付き演算

結果を `Option` として返します。
数学的に正しい答えが得られた場合にはその値を `v` として `Some(v)` を返します。
得られなければ `None` を返します。

```
// The sum of 10 and 20 can be represented as a u8.
assert_eq!(10_u8.checked_add(20), Some(30));

// Unfortunately, the sum of 100 and 200 cannot.
assert_eq!(100_u8.checked_add(200), None);

// Do the addition; panic if it overflows.

let sum = x.checked_add(y).unwrap();

// Oddly, signed division can overflows too, in one particular case.
// A signed n-bit type can represent -2.pow(n - 1), but not 2.pow(n - 1).
assert_eq!(-128_i8.checked_div(-1), None);
```

#### ラップ演算

数学的に正しい答えを値の範囲で除算した余り（剰余）を返します。

```
// The first product can be represented as a u16;
// the second cannot so we get 250000 modulo 2.pow(16).

assert_eq!(100_u16.wrapping_mul(200), 20000);
assert_eq!(500_u16.wrapping_mul(500), 53392);

// Operations on signed types may wrap to negative values.

assert_eq!(500_i16.wrapping_mul(500), -12144);

// In bitwise shift operations, the shift distance is wrapped to fall within the size of the value.
// So a shift of 17 bits in a 16-bit type is a shift of 1.
assert_eq!(5_i16.wrapping_shl(17), 10);
```

すでに説明したように、リリースビルドでは通常の数値演算はこの挙動となります。
これらのメソッドを使うと全てのビルドで同じ挙動にすることができます。

#### 飽和演算

数学的に正しい結果に対して、その型で表現できる最も近い値を返します。
言い方を変えると、結果はその型の最大値もしくは最小値で「クランプ」される。

```
assert_eq!(32760_i16.saturating_add(10), 32767);
assert_eq!(-32760_i16.saturating_sub(10), -32768);
```

除算、剰余、ビット単位シフトには、飽和演算はないです。

#### オーバーフロー演算

`(result, overflowed)` という形のタプルを返します。
ここで `result` はラップ演算で得られる値、 `overflowed` はオーバーフローが起きたことを示す真偽値です。

```
assert_eq!(255_u8.overflowing_sub(2), (253, false));
assert_eq!(255_u8.overflowing_add(2), (1, true));
```

## 浮動小数点数

これらの型は、正と負の無限大、正の `0` と負の `0` 、数ではない値 (not-a-number) を含んでいます。
浮動小数点数の整数部よりも後ろの部分は省略可能ですが、整数リテラルと区別するために、小数部、指数部、型指定子のどれか 1 つはなければなりません。
小数部は小数点のみでもよいです。

型 `f32, f64` は、 IEEE 規格が要求する `INFINITY` (無限大)、 `NEG_INFINITY` (負の無限大)、 `NAN` (数でない値)、 `MIN, MAX` (表現できる最小、最大)を型関連定数として持ちます。

```
assert!((-1. / f32::INFINITY).is_sign_negative());
assert_eq!(-f32::MIN, f32::MAX);
```

## 真偽値

真偽値が必要な場合にも、別の型を用いることを許す言語が多いですが、 Rust は許しません。

`as` 演算子で `bool` 値を整数型に変換することができます。

```
assert_eq!(false as i32, 0);
assert_eq!(true as i32, 1);
```

しかし、 `as` は逆方向の変換はできません。
すなわち数値を `bool` にすることはできません。

`bool` を表現するには 1 ビットしか必要ないが、 Rust では 1 バイトまるまる使います。
これは `bool` 値に対するポインタを作れるようにするためです。

## 文字

Rust は Unicode の 1 文字を表現するのに、 32 ビットの値の `char` 型を用います。
Rust は独立した 1 文字に対しては `char` を用いるが、文字列やテキストのストリームに対しては UTF-8 エンコードを用います。
つまり `String` はテキストを UTF-8 バイト列として保持するのであって、文字の配列として保持するわけではありません。

`char` 型の文字リテラルは、 `'8', '!'` のようにシングルクオートで囲みます。

文字の Unicode コードポイントを 16 進数で書くこともできます。

- 文字のコードポイントが U+000 から U+007F に入っていれば（すなわち ASCII 文字として書けるものであれば）、 `'\xHH'` のように書くことができます。

- 任意の Unicode 文字を `'\u{HHHHHH}'` と書くことができます。アンダースコアで文字列をいくつかのグループに分けてもよいです。

Rust は型システムと動的チェックを用いて、 `char` の値が常に許された範囲におさまることを保証します。
`as` 演算子を用いて `char` を整数型に変換することはできますが、 32 ビットよりも小さい型に変換すると、上位ビットが丸められます。
逆方向の変換に関しては、 `u8` 型のみ `as` 演算子で `char` に変換することができます。

## タプル

タプル (tuple) は、様々な型の組み合わせの 2, 3, 4, ... 個組を表現する型です。
n 個組を n-tuple といいます。
タプルでは `t.4` のように定数のインデックスしか使うことができません。

パターンマッチ構文を用いて、返り値のそれぞれの要素を別の変数に代入できます。

```
let text = "I see the eigenvalue in thine eye";
let (head, tail) = text.split_at(21);
assert_eq!(head, "I see the eigenvalue ");
assert_eq!(tail, "in thine eye");
```

タプルを「退屈な」構造体と考えてもよいです。

0 要素のタプル `()` をユニット型 (unit type) といいます。
この型の唯一の値も `()` と書きます。
Rust では、意味のある値を渡す必要がないにもかかわらず、コンテクストが何らかの型を要求する場合にユニット型を用います。

```
fn swap<T>(x: &mut T, y: &mut T);

fn swap<T>(x: &mut T, y: &muy T) -> (); 
```

上の二つの関数シグネチャは同等です。
上は下の省略記法となっています。

## ポインタ型

Rust にはメモリアドレスを表す型がいくつかあります。
これは Rust がガベージコレクションを用いるほとんどの言語と大きく異なる点です。
Rust はメモリ消費を最小にするように設計されているので、値はデフォルトでネストします。
これはメモリ効率的には素晴らしいのですが、その結果として Rust ではある値から別の値を指す場合には、必ず明示的にポインタを用いなければならなくなっています。
しかし、 Rust は安全なので、ポインタ型は未定義動作をしないように制限されており、 Rust でポインタを正しく使うのははるかに容易になっています。

### 参照

型 `&String` (ref String（レフストリング）) は、 `String` 値への参照で、 `&i32` は `i32` 値への参照です。

まずは、参照を Rust の基本的なポインタと考えるとよいです。
実行時には、 `i32` への参照は、その `i32` のアドレスを保持した 1 ワード長のデータとなります。
`i32` がスタックに置かれていても、ヒープに置かれていても構いません。
式 `&x` は `x` への参照を作成しますが、 Rust の用語でこれを「 `x` への参照を借用する」といいます。
参照 `r` に対して、式 `*r` は、 `r` が指す値を取得します。

Rust の参照は決して `null` になりません。
安全な Rust には `null` 参照を作る方法がありません。
さらに、 Rust は値の所有権と生存期間を管理します。
したがって、ダングリングポインタや、多重フリー、ポインタの無効化などのバグはコンパイル時に取り除くことができます。

Rust の参照には 2 種類あります。

#### `&T`

変更不能な共有参照。ある値に対して複数の共有参照を持つことができますが、値を読み出すことしかできません。
参照先の値を書き換えることはできません。

#### `&mut T`

排他的な可変参照。参照先の値を読み出し、変更することができます。
ある値に対してこの種の参照が存在する間は、その値に対する他の参照は共有参照であれ可変参照であれ作成できません。
つまり、この参照を通してでしか、その値にアクセスすることができません。

Rust はこの共有参照と可変参照の 2 つを使い分けることで、ある値に対して「単一書き込み、複数読み出し」のルールを矯正することもできますし、任意の数の読み出しものを持たせることもできますが、これらを同時に行うことはできません。

### `Box`

ヒープ上に値を確保する最も簡単な方法です。

```
let t = (12, "eggs");
let b = Box::new(t); // allocate a tuple in the heap
```

`b` の型は `Box<(i32, &str)>` となります。 `Box::new()` はタプルを格納するのに十分なメモリをヒープ上に確保します。
`b` が事前にリターンなどで移動 (move) されていない限り、 `b` がスコープから外れると、メモリは即座に解放されます。
移動は Rust がヒープ上に確保した値を処理する上で不可欠な機能になっています。

### raw ポインタ

Rust には、 `*mut T` と `*const T` という raw ポインタ型があります。
raw ポインタについては、 Rust が全く管理してくれないので、これを使うことは安全ではありません。
例えば、 raw ポインタは `null` かもしれないし、すでに解放されている領域をさしているかもしれないし、別の型の値を保持している領域を指しているかもしれません。

しかし、 raw ポインタの参照解決は、 `unsafe` ブロックの中でしかできません。
`unsafe` ブロックは、 Rust の高度な言語機能を用いるためのオプトイン式の機構で、これを用いると安全性を保つ責任はプログラマが背負うことになります。

## 配列、ベクタ、スライス

Rust にはメモリ上に値の列を表現する型が 3 つあります。

### `[T; N]`

型 `T` の `N` 個の値の配列を表します。
配列のサイズはコンパイル時に定まり、型の一部となります。
新しい要素を追加したり、縮小したりすることはできません。

### `Vec<T>`

`T` のベクタで、動的に確保される伸長可能な `T` 型の値の列を表します。
ベクタの要素はヒープ上に撮られるので、要素を追加したり、他のベクタを繋げたり、要素を削除したりして、大きさを任意に変更できます。

`Vec<T>` は 3 つの値で構成されます。要素を保持するためにヒープ上に確保されるバッファへのポインタと、バッファに保持できる容量、現在保持している要素数の 3 つです。
バッファが容量の上限に達しているときに新たな要素を追加しようとすると、より大きなバッファが確保され、現在の要素がそちらにコピーされ、ベクタのポインタと容量が更新されて新しいバッファを指すようになり、古いバッファは解放されます。
ベクタが必要とする要素の数が前もってわかっているなら、 `Vec::new` ではなく `Vec::with_capacity` を用いて、要素を全て保持するのに十分なバッファを用意してベクタを作ることができます。

### `&[T], &mut [T]`

`T` の共有スライス及び `T` の可変スライスと呼ばれ、配列やベクタなどの一部の連続した要素への参照です。
最初の要素へのポインタと、そこからアクセスできる要素の数を持っていると思えばよいです。
可変スライス `&mut [T]` では、要素を読み出すことも変更することもできるが、他のスレッドと共有することはできません。
共有スライス `&[T]` は、複数の読み出しスレッドが共有することができますが、要素を変更することはできません。

スライスの参照はファットポインタ、すなわちスライスの最初の要素を表すポインタと、スライスに含まれる要素数からなる 2 ワードの値です。
通常の参照が、単独の値に対する所有権のないポインタであるのに対して、スライスへの参照は、メモリ上で連続している値の領域に対する所有権のないポインタです。
したがって、同じ型のデータ列に対する関数を書く場合の引数としては、スライスへの参照が適しています。


Rust は 要素へのアクセスが範囲内に収まるかどうかをチェックし、もしおさまならければパニックを起こします。

Rust は、メソッド探索時に、配列への参照を暗黙にスライスに変換するので、スライスのメソッドを配列に対して直接使うことができます。
ベクタや配列に属していると思われがちなメソッドの多くは、実際にはスライスに対して定義されています。

## 文字列型

### 文字列リテラル

文字列リテラルは、ダブルクォートで囲みます。
文字列の行がバックスラッシュで終わった場合には、改行文字と次の行の冒頭の空白文字は削除されます。

Rust  には生文字列 (raw string) という機能があります。
全ての生文字列中のバックスラッシュやホワイトスペース文字は全てそのまま文字列に含まれます。
エスケープシーケンスは認識されません。

```
let default_win_install_path = r"C:\Program Files\Gorillas";
let pattern = Regex::new(r"\d+(\.\d+)*");
```

ダブルクォート文字を生文字列に含めたい場合、開始と終了にハッシュ文字をつければよいです。

```
println!(r###"
    This raw string started with 'r###"'.
    Therefore it does not end until we reach a quote mark ('"')
    followed immediately by three pound signs ('###'):
"###);
```

### バイト文字列

`b` を冒頭につけた文字列リテラルはバイト文字列となります。バイト文字列は Unicode テキストからのスライスではなく、 `u8` 値の列からなります。

```
let method = b"GET";
assert_eq!(method, &[b'G', b'E', b'T']);
```

### メモリ上の文字列

Rust の文字列は Unicode 文字の列だが、 `char` の配列としてメモリに格納されているわけではありません。
文字列は可変長のエンコーディングである UTF-8 で格納されます。
ASCII 文字は 1 バイトで格納されます。
他の文字は複数バイトになります。

`String` は UTF-8 のテキストを保持するサイズ可変なバッファを持ちます。
バッファはヒープに確保されるので、必要に応じてサイズを変更できます。

`&str` は、何か別のものが所有している連続した UTF-8 テキストへの参照で、テキストを「借用」します。
`&str` は、有効な UTF-8 が格納されることが保証されている配列への参照 `&[u8]` 以上のものではないです。

文字列リテラルは、事前に確保されたテキストを参照する `&str` で、テキストは一般にプログラムコードと一緒に読み出し専用メモリ領域におかれます。

`&mut str` は存在しますがほとんど役に立ちません。というのは、 UTF-8 に対する操作のほとんどが全体のバイト列を変更してしまうだが、スライスから参照先を確保し直すことができないからです。
実際、 `&mut str` で利用できる操作は、大文字と小文字を変換する `make_ascii_uppercase, make_ascii_lowercase` だけです。

### 文字列 `String`

`&str` はデータ列に対するファットポインタ `&[T]` に似ています。
`String` は、 `Vec<T>` に対応します。

`String` は他の `String` と共有されないヒープ上のバッファを持ちます。
`String` 変数が移動されないままスコープから外れれば、バッファは自動的に解放されます。

`String` を作る方法はいくつかあります。

- `to_string()` メソッドで `&str` を `String` に変換します。このメソッドは文字列をコピーします。 `to_owned()` メソッドも同じことをします。

- `format!()` マクロは、 `println!()` と同じように動作しますが、新しい `String` を返します。

- 文字の配列、スライス、ベクタには `.concat()` と `join(sep)` の 2 つのメソッドがあります。これらのメソッドはいくつかの文字列から新たな `String` を作成します。

`&str` と `String` のどちらの型を使うべきか、迷ってしまう場合は、 `&str` とするのが妥当なときが多いです。

### 文字列の使用

文字列は、演算子 `==, !=` をサポートします。
2 つの文字列は同じ文字を同じ順番で持っていれば、同じだと判断されます。

ここで注意して欲しいのは、 Unicode の性質のため単純な `char` 単位の比較では期待通りに動かない場合があるということです。
`\u{e9}, \u{301}` は `é` ですが別の文字として扱われます。

## 型エイリアス

`type` キーワードを使って、既存の型に別の名前をつけることができます。


```
type Bytes = Vec<u8>;
```


